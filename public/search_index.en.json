[{"url":"http://127.0.0.1:1111/Fast Robots Stuff/","title":"ECE 4160 Fast Robots Labs","body":""},{"url":"http://127.0.0.1:1111/Fast Robots Stuff/lab2/","title":"Lab 2: IMU","body":"Overview\nIn Lab 2, I integrated a 9DOF IMU with the SparkFun RedBoard Artemis Nano, computed orientation estimates from accelerometer and gyroscope data, analyzed accelerometer noise in the frequency domain, implemented a low-pass filter (LPF), and fused accelerometer + gyroscope estimates with a complementary filter. Finally, I powered the RC car from battery and recorded driving “stunts” to establish a baseline for future autonomous behavior.\nIMU Setup\nHardware connections\nI connected the SparkFun ICM-20948 IMU breakout to the Artemis using the QWIIC connectors (I2C). Below image shows this setup. I also added a visual indicator by blinking the Artemis LED 3 times on boot, there is an image for this as well.\nArtemis + IMU wiring via QWIIC\nArtemis with blue LED indicator\nExample code works\nI verified basic IMU functionality using the SparkFun library example:\nLibrary: SparkFun 9DoF IMU Breakout - ICM 20948 - Arduino Library\nExample: Example1_Basics\nI did modify the code in the example slightly in order to get better print and plotter to work nicely. But this didn't impact the actual values, so there is minimum impact.\nI confirmed that acceleration (mg) and gyroscope (DPS) values updated as expected while rotating and translating the board.\nExample Code IMU Test\nAD0_VAL (what it is + what it should be)\nAD0_VAL represents the least significant address-selection bit for the IMU’s I2C address (effectively selecting between the two possible I2C addresses depending on the AD0/ADR pin state). In practice:\nIf the IMU ADR/AD0 line is left at its default, AD0_VAL should match that default.\nIf the ADR jumper is bridged/closed, AD0_VAL must be changed accordingly.\nIn my setup, AD0_VAL = 1 because I am just using the default configuration.\nInitial sensor behavior (what changes and why)\nFrom the example output + calculated roll, pitch and yaw values for both acceleraometer and gyroscope(shown in later videos):\nAccelerometer: changes with linear acceleration and also reflects gravity. When the board is still but tilted, the acceleration vector changes because gravity is distributed differently across axes. I also notice that the accelerometer's data is very noisy. This is expected, since accelerometers are highly sensitive to small vibrations, mechanical disturbances, and electrical noise.\nGyroscope: changes with angular velocity. When I rotate about an axis, I see a spike primarily on the corresponding gyro axis; when stationary, gyro values return near zero. For the above example, you can see my gyroscope value stay mostly zero, because my motion is mostly slow, resulting in a small angular velocity being measured.\nAnother important thing is the parameters chagnes based on the axis being rotated about, so when you rotate about the x-axis, you see that pitch is changed the most compare to the other 2 axis.\nAccelerometer\nPitch and roll from acceleration\nUsing the lecture equations, I converted raw accelerometer readings into pitch and roll (degrees). I used atan2() for robust quadrant handling.\nThe video below showcase, how obtained 0, -90 and 90 degrees for the pitch and roll from the accelerometer.\nRoll and Pitch IMU Test\nSpecifically, these 5 images below are the static image of me hitting those specific angles.\nAs the images indicates, the accuracy of the accelerometer's is pretty decent, as the values are close to their true values, but not super precise. I did using 2 point calibration to attempt make it a bit better. Specifically for pitch, true 0 degree is about 2 degree, true -90 degree is about -88 degree. This is easy to fix. You just need to add 2 degree offset. The roll value is a bit more complicate. Because true 0 degree is roughly -1.5, true -90 degree is about -91, and true 90 degree is about 92 degree. Using slope functions, we get this, where a is the slope, and b is the offset:\nAccuracy of the accelerometer\n0 degree - both\npitch 90 degree\npitch -90 degree\nroll 90 degree\nroll -90 degree\n0 degree - pitch\n0 degree - roll\npitch 90 degree\npitch -90 degree\nroll 90 degree\nroll -90 degree\nThe calibrated result end up looks pretty good for pitch and roll at different critical values.\nData from Accelerometer\nI made a new command in Artemis code to collect the IMU sensor data with a certain number of samples, in this case 2048 samples, and transmitter them to the python server. Once the data arrives as string, I parse them into separate array by type of data(ie. pitch_a, roll_a, etc.). I then used them to plot graphs for analysis and result purposes.\nThen I use a similar notification handler as Lab 1 for reading the data.\nHere is an example plotting code I used for plotting different graphs.\nRaw pitch and roll vs. time with RC car in proximity\nThe plots above show raw accelerometer-derived pitch and roll over about 6 seconds. Both signals stay near 0° but exhibit high-frequency oscillations—roughly ±1° for pitch and a slightly larger range for roll—indicating sensor noise and vibration from the nearby running car. This raw data is what drives the use of a low-pass filter to reduce noise, which I will analyze in the next section.\nFFT and Low-Pass Filter\nI performed FFT analysis to characterize accelerometer noise and chose a cutoff frequency for the low-pass filter.\nUsing the Frequency Spectrum to Choose a Cutoff Frequency\nTo determine an appropriate cutoff frequency for the low-pass filter, I analyzed the accelerometer-derived pitch and roll signals in the frequency domain using the Fast Fourier Transform (FFT). Before computing the FFT, I subtracted the mean of each signal to remove the dominant DC component caused by gravity, allowing the vibration and noise content to be more clearly observed.\nThe resulting frequency spectra show that the majority of the signal energy is concentrated at very low frequencies, corresponding to slow changes in orientation. Beyond this region, the spectrum becomes relatively flat and noisy, indicating high-frequency vibrations rather than meaningful motion. When the RC car was running nearby, noticeable energy appeared primarily below approximately 5 Hz, with no strong, structured peaks at higher frequencies. Frequencies above this range are dominated by broadband noise caused by motor vibrations and environmental disturbances.\nBased on this observation, I selected a cutoff frequency near 5 Hz for the low-pass filter. This cutoff preserves the low-frequency components associated with real robot motion while attenuating higher-frequency noise. Choosing a cutoff that is too low would oversmooth the signal and suppress legitimate motion (such as a quick tilt or turn), while choosing a cutoff that is too high would allow excessive vibration noise to remain in the signal.\nLow-Pass Filter Design and Effect on the Data\nTo implement the low-pass filter, I used a 4th-order Butterworth filter, which provides a smooth passband and strong attenuation beyond the cutoff frequency. The filter was designed using the inferred sampling frequency of the IMU data and applied using a zero-phase filtfilt operation to avoid phase distortion.\nIn the time domain, the effect of the low-pass filter is clearly visible. The raw pitch and roll signals exhibit rapid, high-frequency oscillations on the order of ±1°, even when the sensor remains near a constant orientation. After filtering, these oscillations are significantly reduced, while the overall trend of the signal is preserved. This confirms that the removed components primarily correspond to noise rather than meaningful motion.\nThe FFT of the filtered signal further validates this choice: frequency components above the cutoff frequency are strongly attenuated, while low-frequency content remains largely unchanged. Together, the frequency-domain and time-domain results demonstrate that the selected cutoff frequency effectively balances noise reduction and signal fidelity.\nRelation to Filter Parameters in Code\nThe cutoff frequency directly determines the filter coefficients used in the Butterworth design. As explained in lecture too, the cutoff frequency $( f_c )$ is related to the time constant $ ( RC )$ by\n$ [\nf_c = \\frac{1}{2\\pi RC}\n] $\nand the smoothing factor $( \\alpha )$ is related to the sampling period $( T )$ by\n$[\n\\alpha = \\frac{T}{T + RC}\n]$\nIn practice, rather than explicitly computing $( \\alpha )$, I implemented the low-pass filter using a digital Butterworth filter, which internally accounts for the sampling frequency and cutoff frequency. This approach provides a more consistent frequency response and better attenuation characteristics than a simple first-order filter.\nBelow are the frequency-domain plots and raw vs. LPF comparisons.\nFFT of accelerometer data — car in proximity\nRaw vs. low-pass filtered accelerometer data\nPitch: raw vs. LPF\nRoll: raw vs. LPF\nAdditional vibration and FFT analysis:\nTo deliberately induce vibrational noise, I placed the IMU on the lab table and gently tapped the table with my hand. As you might notice, the peaks in the following graphs are vibration noise from those impacts—the accelerometer picks up the mechanical shock as high-frequency spikes in pitch and roll. And these spike are generated just by my finger taps. This setup helps characterize how impulsive disturbances affect the raw signal and how well the low-pass filter attenuates them. And you can see the raw signal contains a lot of the vibration noise, but the low-pass filter is able to smooth them out.\nVibration Pitch and Roll — table taps\nVibration frequency analysis — table taps\nVibration FFT — pitch (table taps)\nVibration FFT — roll (table taps)\nRaw vs. low-pass filtered — table-tap vibration noise\nPitch and roll — vibration spikes from table taps\nGyroscope\nPitch, roll, and yaw from gyroscope\nI integrated angular velocity (DPS) over time to obtain pitch, roll, and yaw angles from the gyroscope:\nGyroscope vs. accelerometer\nThe gyroscope and accelerometer use different axis conventions on the ICM-20948 as we learned in lecture. The gyro pitch/roll axes correspond to the accel roll/pitch axes (with a sign flip for pitch). So I had to corrected this mapping in code with this code edit:\nGyroscope vs Accelerometer in orientation\nFor the most part, the gyroscope tracks quick rotations smoothly but drifts over time due to integration error. The accelerometer is more accurate at low frequencies but is noisy. A complementary filter would combines both to get stable and accurate orientation.\nComplementary Filter\nI fused the low-pass filtered accelerometer angles with the integrated gyroscope angles using a complementary filter:\nWith an alpha (0.05) used for both the LPF and the filter weights the gyroscope for short-term stability and the accelerometer for long-term accuracy, I get something like this:\nComplementary filter: gyro vs. LPF accelerometer vs. fused\nHowever, you could notice that graph of the complementary filter is smooth, but not too accracy or it didn't respond to the change with LPF's graph, so that mean I need to increase the contribution of the LPF of the accelerometer, giving smooth and drift-corrected roll and pitch.\nBest Complementary filter: gyro vs. LPF accelerometer vs. fused\nNow this looks better!\nSampling Data\nSpeed up\nI optimized the main loop to sample the IMU as fast as possible:\nNon-blocking data collection: Instead of blocking on myICM.dataReady() inside the command handler, I check dataReady() in the main loop and call collectIMU() only when new data is available. Data is stored in arrays and sent over Bluetooth in a separate command.\nRemoved debug prints in the IMU read path to reduce overhead.\nStart/stop flags so recording only runs when requested via Bluetooth commands.\nThe main loop runs much faster than the IMU produces data, so the IMU is the bottleneck. Comparing Total_Loops (main loop count) to IMU_Count (samples collected) shows the loop cycles many times per IMU sample.\nData storage\nI use separate float arrays for time, raw accel roll/pitch, LPF roll/pitch, gyro roll/pitch/yaw, and complementary filter roll/pitch—10 arrays total. With 4 bytes per float, that is 40 bytes per sample.\nLab 1b global variables use 30,648 bytes. The Artemis has 384 kB RAM, leaving roughly 353 kB for dynamic allocation. At 40 bytes per sample, this allows storing on the order of 8,000+ samples. At ~350 Hz sample rate, that corresponds to roughly 25+ seconds of continuous IMU data.\n5 seconds of IMU data\nI collected at least 5 seconds of IMU data and sent it over Bluetooth to verify the pipeline. Using the first and last timestamps in the CSV:\nRC Stunts\nBelow are videos of the RC car stunts powered by battery.\nRC car stunt 1\nRC car stunt 2"},{"url":"http://127.0.0.1:1111/Fast Robots Stuff/lab-1/","title":"Lab 1: Artemis and Bluetooth","body":"Lab 1A\nDuring section 1A, I installed the Arduino IDE and the corresponding libraries and board manager following a giving tutorial and hooked a physical connection from my computer to communicate with the SparkFun RedBoard Artemis Nano. After selecting the correct Board (RedBoard Artemis Nano) and Port, I verified programming + serial communication by running the required example sketches:\nBasics_blink\nApollo3_serial\nApollo3_analogRead\nPDM_microphoneOutput\nBlink\nThe Artemis board flashed its onboard LED as expected.\nBlink test video\nSerial\nThe Artemis received a string over USB serial and echoed it back as I typed into the Serial Monitor, confirming serial RX/TX.\nMicrophone output test\nAnalogRead with Temperature Sensor\nThe onboard temperature sensor responded to heat (touch / breath), showing changing readings over time. In this case, I was blowing hot air to increase the temperature.\nTemperature sensor test\nMicrophone Output\nThe PDM microphone output changed with voice/whistle input, confirming the microphone pipeline works. In this case, I was whistling in the background to increase the sound frequency.\nMicrophone output test\nPart A of this lab is mainly for setup and test if the microcontroller functions properly with the computer, which it does.\nLab 1B\nIntroduction\nWith regrads to the prelab and background reading, this is what I understand:\nBluetooth Low Energy (BLE) enables a lightweight communication link between my computer and the Artemis board. At a high level:\nThe Artemis acts as a BLE peripheral that advertises a service (UUID).\nThe computer acts as the BLE central, connects to the advertised service, and interacts with characteristics.\nCharacteristics support operations like Read, Write, and Notify. In this lab, I used Write to send commands to the Artemis and Notify to stream messages back to the laptop.\nThe code provided to me supports including but not limited to the following functionality:\nble_arduino.ino: Arduino sketch running on Artemis (defines service + RX/TX characteristics and command handling)\nRobotCommand.h: parses incoming command strings of the form &lt;cmd_type&gt;:&lt;value1&gt;|&lt;value2&gt;|...\nEString.h: safely constructs outgoing strings (including float formatting) without relying on printf float support\ndemo.ipynb: Python/Jupyter notebook used to connect, send commands, and receive notifications\nUseful functions:\nble.connect() / ble.disconnect()\nble.send_command(cmd_type, data)\nble.start_notify(uuid, handler)\nble.bytearray_to_string(byteArray)\nSetup\nInstalled virtual environment tooling: python3 -m pip install --user virtualenv\nCreated venv: python3 -m venv FastRobots_ble\nActivated: source FastRobots_ble/bin/activate\nInstalled packages: pip install numpy pyyaml colorama nest_asyncio bleak jupyterlab\nStarted JupyterLab: jupyter lab\nAfter uuid4(), I updated connections.yaml with my Artemis MAC address (from Serial Monitor) and a unique BLE service UUID.\nArtemis MAC address output\nUpdated connections.yaml (service UUID + MAC)\nConnected successfully to the Artemis Nano board in Python:\nSuccessful BLE connection\nTASK 1\nI sent a string from my computer using ECHO. The Artemis constructed an augmented reply and transmitted it back over the TX string characteristic.\nArtemis:\nPython:\nECHO output received on laptop\nTASK 2\nI sent three floats with SEND_THREE_FLOATS and extracted them on the Artemis.\nArtemis:\nPython:\nSEND_THREE_FLOATS serial output\nTASK 3\nI added GET_TIME_MILLIS, which replies with a timestamp string formatted as T:&lt;millis&gt;. The results of this task is shown in task 4. I also had to add GET_TIME_MILLIS to the cmd_types.py with the right order in the types file.\nArtemis:\nTASK 4\nI set up a minimal notification handler in Python to receive strings from the Artemis via BLE notifications.\nPython:\nNotification handler receiving Artemis strings\nTASK 5\nI ran a short for loop sending 50 GET_TIME_MILLIS repeatedly and used the timestamps received to estimate throughput. I write the for loop in the juypter notebook, equvialently, it is talking the Artemis board 50 times via BLE.\nPython:\nFrom the printed timestamps, the average inter-message gap was approximately 58.66 ms, corresponding to 17.05 messages/sec. Each message being 9 characters long, which means its payload is about 9 bytes (1 byte per character), giving an effective payload throughput of approximately:\ndata rate ≈ (messages/sec) × (bytes/message) = 153.43 bytes/sec\nGET_TIME_MILLIS loop output\nTASK 6\nI implemented an Arduino timestamp buffer (global array) of size 500(arbitray) and added SEND_TIME_DATA to send stored timestamps back to the laptop. You can request to for any integer number of times. It first store the time stamps in the buffer by running millis() the requested number of time. Then it would publish the buffer results one by one to my computer. I had additional logic for handling the buffer overflow, which send all the data once the buffer is full, then clear it and restart the timestamp collection. This method balances between the reliability of the data and availiability of data. Again, I had to add SEND_TIME_DATA to the cmd_types.py with the right order in the types file.\nAdvantage: sampling happens locally without waiting for BLE round-trips.\nImplementation: store up to capacity, then transmit and restart.\nArtemis:\nSEND_TIME_DATA output\nTASK 7\nI added a second buffer array for temperature values (same length as timestamps = 500). Both are global arrays. Each index corresponds to a paired measurement. GET_TEMP_READINGS sends T:&lt;ms&gt; , TEMP:&lt;val&gt; on each line. It allow the users to request the number of times they want to get the data, and it fetch the current time and temp sequentially, so it ensures their value are synchorize. The publish and buffer overflow logic is handled just like TASK 6. Again, I had to add GET_TEMP_READINGS to the cmd_types.py with the right order in the types file.\nArtemis:\nTimestamp + temperature streaming\nTASK 8\nMethod 1 (Task 5) is fetching and sending the data one at a time. It is definitely slower for recording because each sample need to depends on BLE command/response timing, you are wasting a lot of time on sending and recieving communication. It is however useful for simple debugging and low-rate telemetry when real-time interaction matters, especially, if we decided to have a really large buffer, the data might be stale by the time you get on the computer side.\nMethod 2 (Tasks 6–7) is fetching at volumn, and sending one at time. It records data faster because the sampling is local; BLE is only used afterward to transmit stored results. This is could be ideal for burst logging and experiments where high-rate sampling matters more than immediate realtime feedback. The downside is delayed availability of the data on the laptop as I have mentioned, and transmission can still be limited by notification throughput.\nHow quickly can method 2 record data?\nIt is primarily limited by the sensor read + loop overhead on the Artemis. In my test with sending 400 request for SEND_TIME_DATA, recording 400 samples took approximately 13 ms, or roughly 0.03 ms/sample, which is almost 2000 times faster.\nMemory estimate (384 kB RAM):\nEach timestamp is 4 bytes (int), each temp is 4 bytes (float) → 8 bytes per paired sample. Include the global variables I have, which is 34152 bytes, but ignoring other overhead, the theortically upper bound is approximately:\n349848 bytes / 8 ≈ 43731 sample pairs could potentially be stored in the array before the board runs out dynamic memory.\nA more realistic safe capacity is lower depending on current global/static memory usage reported by the Arduino IDE.\nDiscussion and Conclusion\nI learned how BLE services/characteristics map to read/write/notify behavior and how the Artemis acts as a peripheral device. I also learned to write commands to control the Artemis board using lower level libraries like RobotCommand.h. Finally I learned about the limits on how fast Artemis's temperature sensor can be pulled, which is really fast.\nI Implemented a interesting way on handling the buffer overflow for TASK 6-7, it balanced between availability of data as well as reliability of data.\nThe main debugging challenge was make sure that the environment is set up to run the jupyter notebook. I spend way too long on it, when it was just an easy fix. But now I really remember it. Also I thought about perhaps sending the buffer information in one message, which would depend on how long I could make a Estring, theorically I can be it 255 bytes with the Arduino BLE limit, which for TASK 5-6, that's 20-30 messages depending on the length of the time stamp. Realistically, it would not impact the reliability of the data, because the data is already recorded in the buffer, but it can decrease the delay of the delivery of the data.\nCollaboration\nI collaborated with: Ananya Jajodia.\nI referenced: Lucca Correia's site for web design and lab writeup.\nChatGPT was used for: code debugging + website formatting."},{"url":"http://127.0.0.1:1111/","title":"About Me","body":"Shao Stassen\nSenior at Cornell University studying Computer Science with a focus in Robotics\nHere on campus I am doing foundation model and diffusion policy research on the assistive robotic lab EmPRISE. I am also an Autonomous member of the Combat Robotics at Cornell Project Team. I will be updating my site through the semester to reflect my progress in Fast Robots - ECE4160."}]