[{"url":"http://127.0.0.1:1024/","title":"About Me","body":"Shao Stassen\nSenior at Cornell University studying Computer Science with a focus in Robotics\nHere on campus I am doing foundation model and diffusion policy research on the assistive robotic lab EmPRISE. I am also an Autonomous member of the Combat Robotics at Cornell Project Team. I will be updating my site through the semester to reflect my progress in Fast Robots - ECE4160."},{"url":"http://127.0.0.1:1024/Fast Robots Stuff/","title":"ECE 4160 Fast Robots Labs","body":""},{"url":"http://127.0.0.1:1024/Fast Robots Stuff/lab2/","title":"Lab 2: IMU","body":"IMU Setup"},{"url":"http://127.0.0.1:1024/Fast Robots Stuff/lab-1/","title":"Lab 1: Artemis and Bluetooth","body":"Lab 1A\nDuring section 1A, I installed the Arduino IDE and the corresponding libraries and board manager following a giving tutorial and hooked a physical connection from my computer to communicate with the SparkFun RedBoard Artemis Nano. After selecting the correct Board (RedBoard Artemis Nano) and Port, I verified programming + serial communication by running the required example sketches:\nBasics_blink\nApollo3_serial\nApollo3_analogRead\nPDM_microphoneOutput\nBlink\nThe Artemis board flashed its onboard LED as expected.\nBlink test video\nSerial\nThe Artemis received a string over USB serial and echoed it back as I typed into the Serial Monitor, confirming serial RX/TX.\nMicrophone output test\nAnalogRead with Temperature Sensor\nThe onboard temperature sensor responded to heat (touch / breath), showing changing readings over time. In this case, I was blowing hot air to increase the temperature.\nTemperature sensor test\nMicrophone Output\nThe PDM microphone output changed with voice/whistle input, confirming the microphone pipeline works. In this case, I was whistling in the background to increase the sound frequency.\nMicrophone output test\nPart A of this lab is mainly for setup and test if the microcontroller functions properly with the computer, which it does.\nLab 1B\nIntroduction\nWith regrads to the prelab and background reading, this is what I understand:\nBluetooth Low Energy (BLE) enables a lightweight communication link between my computer and the Artemis board. At a high level:\nThe Artemis acts as a BLE peripheral that advertises a service (UUID).\nThe computer acts as the BLE central, connects to the advertised service, and interacts with characteristics.\nCharacteristics support operations like Read, Write, and Notify. In this lab, I used Write to send commands to the Artemis and Notify to stream messages back to the laptop.\nThe code provided to me supports including but not limited to the following functionality:\nble_arduino.ino: Arduino sketch running on Artemis (defines service + RX/TX characteristics and command handling)\nRobotCommand.h: parses incoming command strings of the form &lt;cmd_type&gt;:&lt;value1&gt;|&lt;value2&gt;|...\nEString.h: safely constructs outgoing strings (including float formatting) without relying on printf float support\ndemo.ipynb: Python/Jupyter notebook used to connect, send commands, and receive notifications\nUseful functions:\nble.connect() / ble.disconnect()\nble.send_command(cmd_type, data)\nble.start_notify(uuid, handler)\nble.bytearray_to_string(byteArray)\nSetup\nInstalled virtual environment tooling: python3 -m pip install --user virtualenv\nCreated venv: python3 -m venv FastRobots_ble\nActivated: source FastRobots_ble/bin/activate\nInstalled packages: pip install numpy pyyaml colorama nest_asyncio bleak jupyterlab\nStarted JupyterLab: jupyter lab\nAfter uuid4(), I updated connections.yaml with my Artemis MAC address (from Serial Monitor) and a unique BLE service UUID.\nArtemis MAC address output Updated connections.yaml (service UUID + MAC)\nConnected successfully to the Artemis Nano board in Python:\nSuccessful BLE connection\nTASK 1\nI sent a string from my computer using ECHO. The Artemis constructed an augmented reply and transmitted it back over the TX string characteristic.\nArtemis:\nPython:\nECHO output received on laptop\nTASK 2\nI sent three floats with SEND_THREE_FLOATS and extracted them on the Artemis.\nArtemis:\nPython:\nSEND_THREE_FLOATS serial output\nTASK 3\nI added GET_TIME_MILLIS, which replies with a timestamp string formatted as T:&lt;millis&gt;. The results of this task is shown in task 4. I also had to add GET_TIME_MILLIS to the cmd_types.py with the right order in the types file.\nArtemis:\nTASK 4\nI set up a minimal notification handler in Python to receive strings from the Artemis via BLE notifications.\nPython:\nNotification handler receiving Artemis strings\nTASK 5\nI ran a short for loop sending 50 GET_TIME_MILLIS repeatedly and used the timestamps received to estimate throughput. I write the for loop in the juypter notebook, equvialently, it is talking the Artemis board 50 times via BLE.\nPython:\nFrom the printed timestamps, the average inter-message gap was approximately 58.66 ms, corresponding to 17.05 messages/sec. Each message being 9 characters long, which means its payload is about 9 bytes (1 byte per character), giving an effective payload throughput of approximately:\ndata rate ≈ (messages/sec) × (bytes/message) = 153.43 bytes/sec\nGET_TIME_MILLIS loop output\nTASK 6\nI implemented an Arduino timestamp buffer (global array) of size 500(arbitray) and added SEND_TIME_DATA to send stored timestamps back to the laptop. You can request to for any integer number of times. It first store the time stamps in the buffer by running millis() the requested number of time. Then it would publish the buffer results one by one to my computer. I had additional logic for handling the buffer overflow, which send all the data once the buffer is full, then clear it and restart the timestamp collection. This method balances between the reliability of the data and availiability of data. Again, I had to add SEND_TIME_DATA to the cmd_types.py with the right order in the types file.\nAdvantage: sampling happens locally without waiting for BLE round-trips.\nImplementation: store up to capacity, then transmit and restart.\nArtemis:\nSEND_TIME_DATA output\nTASK 7\nI added a second buffer array for temperature values (same length as timestamps = 500). Both are global arrays. Each index corresponds to a paired measurement. GET_TEMP_READINGS sends T:&lt;ms&gt; , TEMP:&lt;val&gt; on each line. It allow the users to request the number of times they want to get the data, and it fetch the current time and temp sequentially, so it ensures their value are synchorize. The publish and buffer overflow logic is handled just like TASK 6. Again, I had to add GET_TEMP_READINGS to the cmd_types.py with the right order in the types file.\nArtemis:\nTimestamp + temperature streaming\nTASK 8\nMethod 1 (Task 5) is fetching and sending the data one at a time. It is definitely slower for recording because each sample need to depends on BLE command/response timing, you are wasting a lot of time on sending and recieving communication. It is however useful for simple debugging and low-rate telemetry when real-time interaction matters, especially, if we decided to have a really large buffer, the data might be stale by the time you get on the computer side.\nMethod 2 (Tasks 6–7) is fetching at volumn, and sending one at time. It records data faster because the sampling is local; BLE is only used afterward to transmit stored results. This is could be ideal for burst logging and experiments where high-rate sampling matters more than immediate realtime feedback. The downside is delayed availability of the data on the laptop as I have mentioned, and transmission can still be limited by notification throughput.\nHow quickly can method 2 record data?\nIt is primarily limited by the sensor read + loop overhead on the Artemis. In my test with sending 400 request for SEND_TIME_DATA, recording 400 samples took approximately 13 ms, or roughly 0.03 ms/sample, which is almost 2000 times faster.\nMemory estimate (384 kB RAM):\nEach timestamp is 4 bytes (int), each temp is 4 bytes (float) → 8 bytes per paired sample. Include the global variables I have, which is 34152 bytes, but ignoring other overhead, the theortically upper bound is approximately:\n349848 bytes / 8 ≈ 43731 sample pairs could potentially be stored in the array before the board runs out dynamic memory.\nA more realistic safe capacity is lower depending on current global/static memory usage reported by the Arduino IDE.\nDiscussion and Conclusion\nI learned how BLE services/characteristics map to read/write/notify behavior and how the Artemis acts as a peripheral device. I also learned to write commands to control the Artemis board using lower level libraries like RobotCommand.h. Finally I learned about the limits on how fast Artemis's temperature sensor can be pulled, which is really fast.\nI Implemented a interesting way on handling the buffer overflow for TASK 6-7, it balanced between availability of data as well as reliability of data.\nThe main debugging challenge was make sure that the environment is set up to run the jupyter notebook. I spend way too long on it, when it was just an easy fix. But now I really remember it. Also I thought about perhaps sending the buffer information in one message, which would depend on how long I could make a Estring, theorically I can be it 255 bytes with the Arduino BLE limit, which for TASK 5-6, that's 20-30 messages depending on the length of the time stamp. Realistically, it would not impact the reliability of the data, because the data is already recorded in the buffer, but it can decrease the delay of the delivery of the data.\nCollaboration\nI collaborated with: Ananya Jajodia.\nI referenced: Lucca Correia's site for web design and lab writeup.\nChatGPT was used for: code debugging + website formatting."}]